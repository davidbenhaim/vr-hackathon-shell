<html>

<head>
  <title>Augmented Reality Marker Detector</title>
  <script type="text/javascript" src="lib/svd.js"></script>
  <script type="text/javascript" src="lib/posit1.js"></script>
  <script type="text/javascript" src="lib/cv.js"></script>
  <script type="text/javascript" src="lib/aruco.js"></script>
  <script type="text/javascript" src="lib/three.js/build/three.js"></script>
  <script>
    var video, canvas, context, imageData, detector;
    var aruco;
    try{
    	aruco = require('node-aruco');
    }catch(err){
    	console.log('No Aruco :(')
    }
    nativeImage = require('electron').nativeImage;

    // how big the tiles are
    var modelSize = 39.5;

    function getDimensions(){
    	canvas = document.getElementById('canvas');
    	width = canvas.style.width;
    	height = canvas.style.height;
    	return {width: width, height: height}
    }

    function onLoad(){
      video = document.getElementById("video");
      canvas = document.getElementById("canvas");
      context = canvas.getContext("2d");
      dims = getDimensions()
      canvas.width = 640;
      canvas.height = 480;

      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
      if (navigator.getUserMedia){

        function successCallback(stream){
          if (window.webkitURL) {
            video.src = window.webkitURL.createObjectURL(stream);
          } else if (video.mozSrcObject !== undefined) {
            video.mozSrcObject = stream;
          } else {
            video.src = stream;
          }
          // initScene();
          // animate();
        }

        function errorCallback(error){
        }

        navigator.getUserMedia({video: true}, successCallback, errorCallback);

        detector = new AR.Detector();
        posit = new POS.Posit(modelSize, canvas.width)
        requestAnimationFrame(tick);
      }
    }

    var scene, camera, renderer;
    var geometry, material, mesh, texture, sceneMaterial, cameraPlane;

    function initScene() {

      // setup scene and camera
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
      camera.position.z = 1000;

      // add video background texture
      texture = new  THREE.VideoTexture(video);
      cameraPlane = new THREE.PlaneGeometry(1920, 1280);
      cameraMesh = new THREE.Mesh(cameraPlane, new THREE.MeshBasicMaterial({
        color: 0xffffff,
        opacity: 1,
        map: texture
      }))
      cameraMesh.position.z = -600; // TODO
      scene.add(cameraMesh);

      // add a box
      geometry = new THREE.BoxGeometry( 200, 200, 200 );
      material = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );

      mesh = new THREE.Mesh( geometry, material );
      scene.add( mesh );

      renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );
    }

    function animate() {
      if (context) {
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
      }
      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        texture.needsUpdate = true;
      }
      requestAnimationFrame( animate );

      mesh.rotation.x += 0.01;
      mesh.rotation.y += 0.02;

      renderer.render( scene, camera );

    }

    function tick(){
      var start = new Date();
      // dims = getDimensions()
      // canvas.width = dims.width;
      // canvas.height = dims.height;
      requestAnimationFrame(tick);

      if (video.readyState === video.HAVE_ENOUGH_DATA){
        snapshot();
        if(typeof aruco !== "undefined" && aruco !== null) {
        	var markers = aruco.detect(imageData);
        } else {
        	detector.detect(imageData);
        }
        drawCorners(markers);
        drawId(markers);
      }
      // var end = new Date();
      // console.log(end - start);
    }

    function snapshot(){
      context.drawImage(video, 0, 0, canvas.width, canvas.height);
	  if(typeof aruco !== "undefined" && aruco !== null) {
      	imageData = nativeImage.createFromDataURL(canvas.toDataURL()).toJPEG(100);
       } else {
        imageData = context.getImageData(0, 0, canvas.width, canvas.height);
       }

    }

    function drawCorners(markers){
      var corners, corner, i, j;

      context.lineWidth = 3;
      for (i = 0; i !== markers.length; ++ i){
        corners = markers[i].points;

        context.strokeStyle = "red";
        context.beginPath();

        for (j = 0; j !== corners.length; ++ j){
          corner = corners[j];
          context.moveTo(corner.x, corner.y);
          corner = corners[(j + 1) % corners.length];
          context.lineTo(corner.x, corner.y);
        }
        context.stroke();
        context.closePath();

        context.strokeStyle = "green";
        context.strokeRect(corners[0].x - 2, corners[0].y - 2, 4, 4);
      }
    }

    function drawId(markers){
      var corners, corner, x, y, i, j;

      context.strokeStyle = "blue";
      context.lineWidth = 1;

      for (i = 0; i !== markers.length; ++ i){
        corners = markers[i].points;

        x = Infinity;
        y = Infinity;

        for (j = 0; j !== corners.length; ++ j){
          corner = corners[j];

          x = Math.min(x, corner.x);
          y = Math.min(y, corner.y);
        }
        context.strokeText(markers[i].id, x, y)
      }
    }

    function updateScenes(markers){
      var corners, corner, pose, i;

      if (markers.length > 0){
        corners = markers[0].corners;

        for (i = 0; i < corners.length; ++ i){
          corner = corners[i];

          corner.x = corner.x - (canvas.width / 2);
          corner.y = (canvas.height / 2) - corner.y;
        }

        pose = posit.pose(corners);

        updateObject(plane1, pose.bestRotation, pose.bestTranslation);
        updateObject(plane2, pose.alternativeRotation, pose.alternativeTranslation);
        updateObject(model, pose.bestRotation, pose.bestTranslation);

        step += 0.025;

        model.rotation.z -= step;
      }

      texture.children[0].material.map.needsUpdate = true;
    };

    function updateObject(object, rotation, translation){
      object.scale.x = modelSize;
      object.scale.y = modelSize;
      object.scale.z = modelSize;

      object.rotation.x = -Math.asin(-rotation[1][2]);
      object.rotation.y = -Math.atan2(rotation[0][2], rotation[2][2]);
      object.rotation.z = Math.atan2(rotation[1][0], rotation[1][1]);
      object.position.x = translation[0];
      object.position.y = translation[1];
      object.position.z = -translation[2];
    };

    window.onload = onLoad;
  </script>

</head>

<body style="font-family: monospace;">

  <center>
    <video id="video" autoplay="true" style="display: none;"></video>
    <canvas id="canvas" style="width: 100%; margin: 50px;"></canvas>
  </center>

</body>

</html>
